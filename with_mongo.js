const {
    MongoClient
} = require('mongodb');
const {
    execSync
} = require('child_process');
const exec = require('child_process').exec;
const readline = require('readline');
const request = require('request');
let async = require('async');
var colors = require('colors');

const url = 'mongodb://localhost:27017';
const client = new MongoClient(url);
const fs = require('fs');


client.connect().then(() => {
    start()
});
console.log('Connected successfully to server\n');

const dbName = 'automation';
const db = client.db(dbName);



function start() {

    const r1 = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    //take the domain name and list the subdomains
    r1.question("Enter the domain name:\t".brightBlue, (answer) => {
        let subfinder_command = `subfinder -d ${answer} -silent -o ${answer}.txt`;
        exec(subfinder_command, (stderr, stdout) => {
            console.log(`subdomain list\n`.green, stdout);
            //console.log('subdomains added to subdomains.txt file\n'.green);
            web_asset_discovery(answer);
        });
    });


    //find out web assets from the subdomain list
    async function web_asset_discovery(answer) {

        let httpx_command = `httpx -l ${answer}.txt -sc -silent -nc`;
        const assets = await execSync(httpx_command);
        const outputString = assets.toString().trim().split("\n");
        console.log(`web assets list\n`.green, outputString);
        processWeb_assets(outputString, answer);

    }

    //processing web assets and storing in database
    async function processWeb_assets(outputString, answer) {

        try {
            for (const line of outputString) {
                const [domainName, statusCode] = line.split(' ');
                await db.collection('web_assets').insertOne({
                    web_asset_of: answer,
                    domainName,
                    statusCode
                });
            }
            console.log('\nWeb assets stored in Database successfully\n');

            

        } catch (error) {
            console.error(`Error storing web assets in MongoDB: ${error}`);
        } finally {
            nuclei_scanner(answer);
        }

    }

    //running nuclei scanner
    async function nuclei_scanner(answer) {
    try {
        const result = await db.collection('web_assets').findOne({
            scan: null,
            web_asset_of: answer
        });

        if(!result) { console.log(`\nall records done\n`.green);

          generate_report(answer);

        }

        else {

        console.log(`picked up the domain\n${result.domainName}\n`.green);

        let nuclei_command = `nuclei -u ${result.domainName} -silent --no-color`;
        const outputBuffer = await execSync(nuclei_command, {
            maxBuffer: 1024 * 1024
        });

        console.log(`vulnerability details for ${result.domainName}\n\n${outputBuffer.toString().trim()}\n`.red);

        const vulnerability_details = outputBuffer.toString().trim().split('\n');

        processDetails(vulnerability_details, result, answer);

        }

        

    } catch (error) {
        console.error('Error querying web_assets collection:', error);
    }
}


//processing nuclei results and storing into database
async function processDetails(vulnerability_details, result, answer) {
    
    const regex = /\[([^\]]+)\] \[([^\]]+)\] \[([^\]]+)\] (.+)/;


    try {
        
        for (const line of vulnerability_details) {

            const match = regex.exec(line);

            //console.log(`match results\n`.green,match);


            if (match) {

                await db.collection('vulnerability_details').insertOne({
                  web_asset_of: answer,
                  domain: result.domainName,
                    category: match[1],
                    protocol: match[2],
                    severity: match[3],
                    details: match[4]
                });

                await db.collection('web_assets').updateOne({
                    _id: result._id
                }, {
                    $set: {
                        scan: 1
                    }
                });

                

            } else {
                console.log("No match found");
            }

        }
        
        console.log(`domain ${result.domainName} is completed and taking another domain\n`);

        

    } catch (error) {
        console.error(`Error storing nuclei reusults in MongoDB: ${error}`);
    } finally {
        nuclei_scanner(answer);
    }

}


//report generation
async function generate_report(answer) {
  try {
    
    const vulnerabilities = await db.collection('vulnerability_details').find({ web_asset_of: answer, severity:{$in:['high','medium','low']} }).toArray();

    const htmlReport = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Vulnerability Report</title>
      <style>
        body {
          font-family: Arial, sans-serif;
          margin: 20px;
        }

        table {
          border-collapse: collapse;
          width: 100%;
        }

        th, td {
          border: 1px solid #dddddd;
          text-align: left;
          padding: 8px;
        }

        th {
          background-color: #f2f2f2;
        }
      </style>
    </head>
    <body>
    
      <h1>Vulnerability Report for ${answer}</h1>
    
      <table>
        <tr>
          <th>Domain</th>
          <th>Category</th>
          <th>Protocol</th>
          <th>Severity</th>
          <th>Details</th>
        </tr>
    
        ${vulnerabilities.map(vulnerability => `
          <tr>
            <td>${vulnerability.domain}</td>
            <td>${vulnerability.category}</td>
            <td>${vulnerability.protocol}</td>
            <td>${vulnerability.severity}</td>
            <td>${vulnerability.details}</td>
          </tr>
        `).join('')}
    
      </table>
    
    </body>
    </html>
    `;

    const fileName = `VulnerabilityReport_${answer}.html`;

    // Save the HTML report to a file
    fs.writeFileSync(fileName, htmlReport);

    console.log(`HTML Report saved to ${fileName}`);
  } catch (error) {
    console.error(`Error generating and saving HTML report: ${error}`);
  }
}


}
